
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. Minimizing memory usage: a matrix-free iterative solver &#8212; The BIE Book</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="canonical" href="https://tbenthompson.com/book/tdes/free_matvec.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Low rank approximation of BEM matrices with adaptive cross approximation (ACA)." href="low_rank.html" />
    <link rel="prev" title="2. A fault and topography mesh of the South America subduction zone." href="sa_geometry.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      <h1 class="site-logo" id="site-title">The BIE Book</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Boundary integral method tutorials
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The TDE sequence: triangular dislocation elements
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sa_tdes.html">
   1. Using TDEs to build a fault model with topography.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sa_geometry.html">
   2. A fault and topography mesh of the South America subduction zone.
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. Minimizing memory usage: a matrix-free iterative solver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="low_rank.html">
   4. Low rank approximation of BEM matrices with adaptive cross approximation (ACA).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hmatrix.html">
   5. Hierarchical matrices for triangular dislocation elements.
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The QBX sequence: quadrature by expansion
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../c1qbx/part1_nearfield.html">
   1. Near-field evaluation via quadrature by expansion (QBX).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../c1qbx/part2_screw_dislocation.html">
   2. More quadrature by expansion (QBX) examples for the Laplace equation: fun with screw dislocations
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Back matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../references.html">
   References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../thanks.html">
   Thanks!
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/tdes/free_matvec.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/tdes/free_matvec.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/tbenthompson/BIE_book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/tbenthompson/BIE_book/issues/new?title=Issue%20on%20page%20%2Ftdes/free_matvec.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/tbenthompson/BIE_book/master?urlpath=tree/tdes/free_matvec.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-deal-with-dense-bem-matrices">
   3.1. How to deal with dense BEM matrices?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-demonstration-on-a-large-mesh">
   3.2. A demonstration on a large mesh.
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#iterative-linear-solution">
   3.3. Iterative linear solution
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#performance-and-convergence">
   3.4. Performance and convergence
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="minimizing-memory-usage-a-matrix-free-iterative-solver">
<h1><span class="section-number">3. </span>Minimizing memory usage: a matrix-free iterative solver<a class="headerlink" href="#minimizing-memory-usage-a-matrix-free-iterative-solver" title="Permalink to this headline">¶</a></h1>
<div class="section" id="how-to-deal-with-dense-bem-matrices">
<h2><span class="section-number">3.1. </span>How to deal with dense BEM matrices?<a class="headerlink" href="#how-to-deal-with-dense-bem-matrices" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="sa_tdes.html"><span class="doc std std-doc">In the previous section, I explained how to directly discretize a free surface using TDEs</span></a>. A downside of this approach is that the surface matrix can get very large very quickly. If I make the width of an element half as large, then there will be 2x many elements per dimension and 4x as many elements overall. And because the interaction matrix is dense, 4x as many elements leads to 16x as many matrix entries. In other words, <span class="math notranslate nohighlight">\(n\)</span>, the number of elements, scales like <span class="math notranslate nohighlight">\(O(h^2)\)</span> in terms of the element width <span class="math notranslate nohighlight">\(h\)</span>. And the number of matrix rows or columns is exactly <span class="math notranslate nohighlight">\(3n\)</span> (the 3 comes from the vector nature of the problem). That requires storing <span class="math notranslate nohighlight">\(9n^2\)</span> entries. And, even worse, using a direct solver (LU decomposition, Gaussian elimination, etc) with such a matrix requires time like <span class="math notranslate nohighlight">\(O(n^3)\)</span>. Even for quite small problems with 10,000 elements, the cost of storage and solution get very large. And without an absolutely enormous machine or a distributed parallel implementation, solving a problem with 200,000 elements will just not be possible. On the other hand, in an ideal world, it would be nice to be able to solve problems with millions or even tens or hundreds of millions of elements.</p>
<p>Fundamentally, the problem is that the interaction matrix is dense. There are two approaches for resolving this problem:</p>
<ol class="simple">
<li><p>Don’t store the matrix!</p></li>
<li><p>Compress the matrix by taking advantage of low rank sub-blocks.</p></li>
</ol>
<p>Eventually approach #2 will be critical since it is scalable up to very large problems. And that’s exactly what I’ll do in the next sections where I’ll investigate low-rank methods and hierarchical matrices (H-matrices). However, here, I’ll demonstrate approach #1 by using a matrix-free iterative solver. Ultimately, this is just a small patch on a big problem and it won’t be a sustainable solution. But, it’s immediately useful when you don’t have a working implementation, are running into RAM constraints and are okay with a fairly slow solution. It’s also useful to introduce iterative linear solvers since they are central to solving BEM linear systems.</p>
<p>When we solve a linear system without storing the matrix, <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix-free_methods">the method is called “matrix-free”</a>. Generally, we’ll just recompute any matrix entry whenever we need. How does this do algorithmically? The storage requirements drop to just the <span class="math notranslate nohighlight">\(O(n)\)</span> source and observation info instead of the <span class="math notranslate nohighlight">\(O(n^2)\)</span> dense matrix. And, as I’ll demonstrate, for some problems, the runtime will drop to <span class="math notranslate nohighlight">\(O(n^2)\)</span> instead of <span class="math notranslate nohighlight">\(O(n^3)\)</span> because solving linear systems will be possible with a fixed and fairly small number of matrix-vector products.</p>
</div>
<div class="section" id="a-demonstration-on-a-large-mesh">
<h2><span class="section-number">3.2. </span>A demonstration on a large mesh.<a class="headerlink" href="#a-demonstration-on-a-large-mesh" title="Permalink to this headline">¶</a></h2>
<p>To get started, I’ll just copy the code to set up the linear system for the South America problem from the previous section. But, as a twist, I’ll going to use a mesh with several times more elements. This surface mesh has 28,388 elements. As a result, the matrix would have 3x that many rows and columns and would require 58 GB of memory to store. That’s still small enough that it could be stored on a medium sized workstation. But, it’s too big for my personal computer!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cutde</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">pyproj</span> <span class="kn">import</span> <span class="n">Transformer</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;text.usetex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="o">%</span><span class="k">config</span> InlineBackend.figure_format=&#39;retina&#39;
<span class="p">(</span><span class="n">surf_pts_lonlat</span><span class="p">,</span> <span class="n">surf_tris</span><span class="p">),</span> <span class="p">(</span><span class="n">fault_pts_lonlat</span><span class="p">,</span> <span class="n">fault_tris</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
    <span class="s2">&quot;sa_mesh16_7216.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Memory required to store this matrix: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Memory required to store this matrix:  58.023255168
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span>
    <span class="s2">&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;+proj=geocent +datum=WGS84 +units=m +no_defs&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">surf_pts_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
        <span class="n">surf_pts_lonlat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">surf_pts_lonlat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">surf_pts_lonlat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">fault_pts_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
        <span class="n">fault_pts_lonlat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fault_pts_lonlat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fault_pts_lonlat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">surf_tri_pts_xyz</span> <span class="o">=</span> <span class="n">surf_pts_xyz</span><span class="p">[</span><span class="n">surf_tris</span><span class="p">]</span>
<span class="n">surf_xyz_to_tdcs_R</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">compute_efcs_to_tdcs_rotations</span><span class="p">(</span><span class="n">surf_tri_pts_xyz</span><span class="p">)</span>

<span class="n">fault_centers_lonlat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fault_pts_lonlat</span><span class="p">[</span><span class="n">fault_tris</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fault_lonlat_to_xyz_T</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">compute_projection_transforms</span><span class="p">(</span>
    <span class="n">fault_centers_lonlat</span><span class="p">,</span> <span class="n">transformer</span>
<span class="p">)</span>

<span class="n">fault_tri_pts_xyz</span> <span class="o">=</span> <span class="n">fault_pts_xyz</span><span class="p">[</span><span class="n">fault_tris</span><span class="p">]</span>
<span class="n">fault_xyz_to_tdcs_R</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">compute_efcs_to_tdcs_rotations</span><span class="p">(</span><span class="n">fault_tri_pts_xyz</span><span class="p">)</span>

<span class="n">fault_tri_pts_lonlat</span> <span class="o">=</span> <span class="n">fault_pts_lonlat</span><span class="p">[</span><span class="n">fault_tris</span><span class="p">]</span>
<span class="n">fault_tdcs2_to_lonlat_R</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">compute_efcs_to_tdcs_rotations</span><span class="p">(</span><span class="n">fault_tri_pts_lonlat</span><span class="p">)</span>

<span class="n">strike_lonlat</span> <span class="o">=</span> <span class="n">fault_tdcs2_to_lonlat_R</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">dip_lonlat</span> <span class="o">=</span> <span class="n">fault_tdcs2_to_lonlat_R</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

<span class="n">strike_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fault_lonlat_to_xyz_T</span> <span class="o">*</span> <span class="n">strike_lonlat</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">strike_xyz</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">strike_xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">dip_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fault_lonlat_to_xyz_T</span> <span class="o">*</span> <span class="n">dip_lonlat</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">dip_xyz</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dip_xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

<span class="n">ft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="c1"># The normal vectors for each triangle are the third rows of the XYZ-&gt;TDCS rotation matrices.</span>
<span class="n">Vnormal</span> <span class="o">=</span> <span class="n">surf_xyz_to_tdcs_R</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">surf_centers_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">surf_tri_pts_xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">surf_tri_pts_xyz_conv</span> <span class="o">=</span> <span class="n">surf_tri_pts_xyz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

<span class="c1"># The rotation matrix from TDCS to XYZ is the transpose of XYZ to TDCS.</span>
<span class="c1"># The inverse of a rotation matrix is its transpose.</span>
<span class="n">surf_tdcs_to_xyz_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">surf_xyz_to_tdcs_R</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Proceeding like the previous section, the next step would be to construct our surface to surface left hand side matrix. But, instead, I’m just going to compute the action of that matrix without ever storing the entire matrix. Essentially, each matrix entry will be recomputed whenever it is needed. The <code class="docutils literal notranslate"><span class="pre">cutde.disp_free</span></code> and <code class="docutils literal notranslate"><span class="pre">cutde.strain_free</span></code> were written for this purpose.</p>
<p>First, let’s check that the <code class="docutils literal notranslate"><span class="pre">cutde.disp_free</span></code> matrix free TDE computation is doing what I said it does. That is, it should be computing a matrix vector product. Since our problem is too big to generate the full matrix in memory, I’ll just use the first 100 elements for this test.</p>
<p>First, I’ll compute the matrix form. This should look familiar! I multiply the matrix by a random slip vector.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">surf_centers_xyz</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">Vnormal</span><span class="p">)[:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_matrix</span><span class="p">(</span><span class="n">test_centers</span><span class="p">,</span> <span class="n">surf_tri_pts_xyz_conv</span><span class="p">[:</span><span class="mi">100</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
    <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">slip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
<span class="n">correct_disp</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">slip</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And now the matrix free version. Note that the slip is passed to the <code class="docutils literal notranslate"><span class="pre">disp_free</span></code> function. This makes sense since it is required for a matrix-vector product even though it is not required to construct the matrix with <code class="docutils literal notranslate"><span class="pre">cutde.disp_matrix</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_disp</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_free</span><span class="p">(</span>
    <span class="n">test_centers</span><span class="p">,</span> <span class="n">surf_tri_pts_xyz_conv</span><span class="p">[:</span><span class="mi">100</span><span class="p">],</span> <span class="n">slip</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="mf">0.25</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And let’s calculate the error… It looks good for the first element. For 32-bit floats, this is machine precision.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">err</span> <span class="o">=</span> <span class="n">correct_disp</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="n">test_disp</span>
<span class="n">err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1.7881393e-07,  3.5762787e-07, -5.2154064e-07], dtype=float32)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3.119628e-07, 1.5199184e-06)
</pre></div>
</div>
</div>
</div>
<p>Okay, now that I’ve shown that <code class="docutils literal notranslate"><span class="pre">cutde.disp_free</span></code> is trustworthy, let’s construct the full action of the left-hand side matrix. We need to transform all the rotation and extrapolation steps into a form that makes sense in an “on the fly” setting where we’re not storing a matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">offset_centers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">surf_centers_xyz</span> <span class="o">-</span> <span class="n">off</span> <span class="o">*</span> <span class="n">Vnormal</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span> <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
<span class="n">surf_xyz_to_tdcs_R</span> <span class="o">=</span> <span class="n">surf_xyz_to_tdcs_R</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

<span class="c1"># The extrapolate to the boundary step looked like:</span>
<span class="c1"># lhs = 2 * eps_mats[1] - eps_mats[0]</span>
<span class="c1"># This array stores the coefficients so that we can apply that formula</span>
<span class="c1"># on the fly.</span>
<span class="n">extrapolation_mult</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Step 1) Rotate slip into the TDE-centric coordinate system.</span>
    <span class="n">slip_xyz</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
    <span class="n">slip_tdcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">surf_xyz_to_tdcs_R</span> <span class="o">*</span> <span class="n">slip_xyz</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Step 2) Compute the two point extrapolation to the boundary.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">offset_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">extrapolation_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_free</span><span class="p">(</span>
            <span class="n">offset_centers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">surf_tri_pts_xyz_conv</span><span class="p">,</span> <span class="n">slip_tdcs</span><span class="p">,</span> <span class="mf">0.25</span>
        <span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Step 3) Don&#39;t forget the diagonal Identity matrix term!</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">matvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 8.09 s, sys: 6.04 ms, total: 8.1 s
Wall time: 8.1 s
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-0.01125255,  0.47539443,  0.14941071, ..., -0.07906851,  0.36050078,  0.25428882], dtype=float32)
</pre></div>
</div>
</div>
</div>
<p>Great! We computed a matrix-free matrix-vector product! This little snippet below will demonstrate that the memory usage is still well under 1 GB proving that we’re not storing a matrix anywhere.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">psutil</span>

<span class="n">process</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">memory_info</span><span class="p">()</span><span class="o">.</span><span class="n">rss</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.179437568
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="iterative-linear-solution">
<h2><span class="section-number">3.3. </span>Iterative linear solution<a class="headerlink" href="#iterative-linear-solution" title="Permalink to this headline">¶</a></h2>
<p>Okay, so how do we use this matrix-vector product to solve the linear system? Because the entire matrix is never in memory, direct solvers like LU decomposition or Cholesky decomposition are no longer an option. But, iterative linear solvers are still an option. The <a class="reference external" href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient (CG) method</a> is a well-known example of an iterative solver. However, CG requires a symmetric positive definite matrix. Because our columns come from integrals over elements but our rows come from observation points, there is an inherent asymmetry to the boundary element matrices we are producing here. <a class="reference external" href="https://en.wikipedia.org/wiki/Generalized_minimal_residual_method">GMRES</a> is an iterative linear solver that tolerates asymmetry. It’s specifically a type of <a class="reference external" href="https://en.wikipedia.org/wiki/Krylov_subspace">“Krylov subspace”</a> iterative linear solver and as such requires only the set of vectors:</p>
<div class="amsmath math notranslate nohighlight" id="equation-61d51173-3f0d-4c48-be3e-71828432b061">
<span class="eqno">(3.1)<a class="headerlink" href="#equation-61d51173-3f0d-4c48-be3e-71828432b061" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\{b, Ab, A^2b, ..., A^nb\}
\end{equation}\]</div>
<p>As such, only having an implementation of the matrix vector product <span class="math notranslate nohighlight">\(Ab\)</span> is required since the later iterates can be computed with multiple matrix vector product. For example, <span class="math notranslate nohighlight">\(A^2b = A(Ab)\)</span>.</p>
<p>To start, we compute the right-hand side which is nothing new or fancy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">slip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fault_xyz_to_tdcs_R</span> <span class="o">*</span> <span class="n">dip_xyz</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_free</span><span class="p">(</span>
    <span class="n">surf_centers_xyz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">),</span> <span class="n">fault_pts_xyz</span><span class="p">[</span><span class="n">fault_tris</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ft</span><span class="p">),</span> <span class="n">slip</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/home/tbent/Dropbox/active/eq/cutde/cutde/fullspace.py:69: UserWarning: The slips input array has type float64 but needs to be converted to dtype float32. Converting slips to float32 may be expensive.
  warnings.warn(
/home/tbent/Dropbox/active/eq/cutde/cutde/fullspace.py:78: UserWarning: The slips input array has Fortran ordering. Converting to C ordering. This may be expensive.
  warnings.warn(
</pre></div>
</div>
</div>
</div>
<p>Now, the fun stuff: Here, I’ll use the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.gmres.html"><code class="docutils literal notranslate"><span class="pre">scipy</span></code> implementation of GMRES</a>. First, we need to do use the <code class="docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code> interface to wrap our <code class="docutils literal notranslate"><span class="pre">matvec</span></code> function in a form that the <code class="docutils literal notranslate"><span class="pre">gmres</span></code> function will recognize as a something that represents a linear system that can be solved.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">spla</span>

<span class="c1"># The number of rows and columns</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

<span class="c1"># The matrix vector product function that serves as the &quot;backend&quot; for the LinearOperator.</span>
<span class="c1"># This is just a handy wrapper around matvec to track the number of matrix-vector products</span>
<span class="c1"># used during the linear solve process.</span>
<span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">M</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n_matvec&quot;</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="s2">&quot;took&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="n">M</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lhs</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rhs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">lhs</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(85164, 85164)
</pre></div>
</div>
</div>
</div>
<p>And then we can pass that <code class="docutils literal notranslate"><span class="pre">LinearOperator</span></code> as the left hand side of a system of equations to <code class="docutils literal notranslate"><span class="pre">gmres</span></code>. I’m also going to pass a simple callback that will print the current residual norm at each step of the iterative solver and require a solution tolerance of <code class="docutils literal notranslate"><span class="pre">1e-4</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>26.985018
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">soln</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">gmres</span><span class="p">(</span>
    <span class="n">lhs</span><span class="p">,</span>
    <span class="n">rhs</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
    <span class="n">restart</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">callback_type</span><span class="o">=</span><span class="s2">&quot;pr_norm&quot;</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 1 took 8.121688604354858
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 2 took 8.087446212768555
0.21284150158882
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 3 took 8.165718793869019
0.026337904611568017
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 4 took 8.187507152557373
0.0058701005433943266
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 5 took 8.206445217132568
0.0016042871687649372
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 6 took 8.201500177383423
0.0004220627227557851
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_matvec 7 took 8.118964910507202
9.5677343550821e-05
</pre></div>
</div>
</div>
</div>
<p>As the figures below demonstrate, only eight matrix-vector products got us a great solution!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inverse_transformer</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span>
    <span class="s2">&quot;+proj=geocent +datum=WGS84 +units=m +no_defs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">surf_xyz_to_lonlat_T</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">compute_projection_transforms</span><span class="p">(</span>
    <span class="n">surf_centers_xyz</span><span class="p">,</span> <span class="n">inverse_transformer</span>
<span class="p">)</span>
<span class="n">surf_xyz_to_lonlat_T</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">surf_xyz_to_lonlat_T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">soln_lonlat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">surf_xyz_to_lonlat_T</span> <span class="o">*</span> <span class="n">soln</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span>
        <span class="n">surf_pts_lonlat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">surf_pts_lonlat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">surf_tris</span><span class="p">,</span> <span class="n">soln_lonlat</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">85</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;$u_{</span><span class="se">\\</span><span class="s2">textrm</span><span class="si">{east}</span><span class="s2">}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$u_{</span><span class="se">\\</span><span class="s2">textrm</span><span class="si">{north}</span><span class="s2">}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$u_{</span><span class="se">\\</span><span class="s2">textrm</span><span class="si">{up}</span><span class="s2">}$&quot;</span><span class="p">][</span><span class="n">d</span><span class="p">]</span>
    <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/free_matvec_25_0.png" src="../_images/free_matvec_25_0.png" />
</div>
</div>
</div>
<div class="section" id="performance-and-convergence">
<h2><span class="section-number">3.4. </span>Performance and convergence<a class="headerlink" href="#performance-and-convergence" title="Permalink to this headline">¶</a></h2>
<p>An important thing to note about the solution above is that only a few matrix-vector products are required to get to a high-level of accuracy. GMRES (and many other iterative linear and nonlinear optimization algorithms) converges at a rate proportional to the condition number of the matrix <span id="id1">[<a class="reference internal" href="../references.html#id169">Saad and Schultz, 1986</a>]</span>. So in order to productively use an iterative linear solver, we need to have a matrix with a small condition number. It turns out that these free surface self-interaction matrices have condition numbers that are very close to 1.0, meaning that all the eigenvalues are very similar in magnitude. As a result, a highly accurate solution with GMRES requires less than ten matrix-vector products even for very large matrices.</p>
<p>Because of this dependence on the condition number, in the worst case, iterative solvers are not faster than a direct solver. However, suppose that we need only 10 matrix-vector products. Then, the runtime is approximately <span class="math notranslate nohighlight">\(10(2n^2)\)</span> because each matrix-vector product requires <span class="math notranslate nohighlight">\(2n^2\)</span> operations (one multiplication and one addition per matrix entry). As a result, GMRES is solving the problem in <span class="math notranslate nohighlight">\(O(n^2)\)</span> instead of the <span class="math notranslate nohighlight">\(O(n^3)\)</span> asymptotic runtime of direct methods like LU decomposition. So, in addition to requiring less memory, the matrix free method here forced us into actually using a faster linear solver. Of course, LU decomposition comes out ahead again if we need to solve many linear systems with the same left hand side and different right hand sides. That is not the case here but would be relevant for many other problems (e.g. problems involving time stepping).</p>
<p>The mess of code below builds a few figures that demonstrate these points regarding performance and accuracy as a function of the number of elements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">fault_L</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="n">fault_H</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="n">fault_D</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">fault_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="o">-</span><span class="n">fault_L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fault_D</span><span class="p">],</span>
        <span class="p">[</span><span class="n">fault_L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fault_D</span><span class="p">],</span>
        <span class="p">[</span><span class="n">fault_L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fault_D</span> <span class="o">-</span> <span class="n">fault_H</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">fault_L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fault_D</span> <span class="o">-</span> <span class="n">fault_H</span><span class="p">],</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="n">fault_tris</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n_els_per_dim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">48</span><span class="p">]:</span>
    <span class="n">surf_L</span> <span class="o">=</span> <span class="mi">4000</span>
    <span class="n">mesh_xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">surf_L</span><span class="p">,</span> <span class="n">surf_L</span><span class="p">,</span> <span class="n">n_els_per_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mesh_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">surf_L</span><span class="p">,</span> <span class="n">surf_L</span><span class="p">,</span> <span class="n">n_els_per_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mesh_xg</span><span class="p">,</span> <span class="n">mesh_yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mesh_xs</span><span class="p">,</span> <span class="n">mesh_ys</span><span class="p">)</span>
    <span class="n">surf_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh_xg</span><span class="p">,</span> <span class="n">mesh_yg</span><span class="p">,</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">mesh_yg</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">surf_tris</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">n_els_per_dim</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="n">j</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_els_per_dim</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_els_per_dim</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">mesh_xs</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">mesh_ys</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">surf_tris</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="n">surf_tris</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="n">surf_tris</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">surf_tris</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">surf_tri_pts</span> <span class="o">=</span> <span class="n">surf_pts</span><span class="p">[</span><span class="n">surf_tris</span><span class="p">]</span>
    <span class="n">surf_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">surf_tri_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">fault_surf_mat</span> <span class="o">=</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_matrix</span><span class="p">(</span><span class="n">surf_centroids</span><span class="p">,</span> <span class="n">fault_pts</span><span class="p">[</span><span class="n">fault_tris</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">)</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fault_surf_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">eps_mats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.002</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">]</span>
    <span class="n">offset_centers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">surf_tri_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="n">offsets</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
        <span class="n">eps_mats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutde</span><span class="o">.</span><span class="n">disp_matrix</span><span class="p">(</span><span class="n">offset_centers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">surf_pts</span><span class="p">[</span><span class="n">surf_tris</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">))</span>
    <span class="n">lhs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps_mats</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps_mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lhs_reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
    <span class="n">lhs_reordered</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">lhs_reordered</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">lhs_reordered</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">lhs_reordered</span> <span class="o">=</span> <span class="n">lhs_reordered</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="p">(</span><span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">lhs_reordered</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">lhs_reordered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">direct_build_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">soln</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">lhs_reordered</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">direct_solve_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">extrapolation_mult</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">slip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">surf_centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">xrshp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">slip</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xrshp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">slip</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xrshp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">slip</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xrshp</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">offset_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">extrapolation_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutde</span><span class="o">.</span><span class="n">disp_free</span><span class="p">(</span>
                <span class="n">offset_centers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">surf_tri_pts</span><span class="p">,</span> <span class="n">slip</span><span class="p">,</span> <span class="mf">0.25</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">x</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">M</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">M</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lhs</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rhs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">soln_iter</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">gmres</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">iterative_runtime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">l1_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">soln_iter</span> <span class="o">-</span> <span class="n">soln</span><span class="p">)</span> <span class="o">/</span> <span class="n">soln</span><span class="p">))</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">l1_err</span><span class="o">=</span><span class="n">l1_err</span><span class="p">,</span>
            <span class="n">n_elements</span><span class="o">=</span><span class="n">surf_tris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span>
            <span class="n">direct_build_time</span><span class="o">=</span><span class="n">direct_build_time</span><span class="p">,</span>
            <span class="n">direct_solve_time</span><span class="o">=</span><span class="n">direct_solve_time</span><span class="p">,</span>
            <span class="n">iterative_runtime</span><span class="o">=</span><span class="n">iterative_runtime</span><span class="p">,</span>
            <span class="n">direct_memory</span><span class="o">=</span><span class="n">rhs</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span> <span class="n">lhs_reordered</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
            <span class="n">iterative_memory</span><span class="o">=</span><span class="n">rhs</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>
<span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;direct_runtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;direct_build_time&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;direct_solve_time&quot;</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">results_df</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>l1_err</th>
      <th>n_elements</th>
      <th>iterations</th>
      <th>direct_build_time</th>
      <th>direct_solve_time</th>
      <th>iterative_runtime</th>
      <th>direct_memory</th>
      <th>iterative_memory</th>
      <th>direct_runtime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000390</td>
      <td>8</td>
      <td>6</td>
      <td>0.001875</td>
      <td>0.000321</td>
      <td>2.618677</td>
      <td>4800</td>
      <td>192</td>
      <td>0.002196</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.000052</td>
      <td>32</td>
      <td>7</td>
      <td>0.002115</td>
      <td>0.000351</td>
      <td>0.052526</td>
      <td>74496</td>
      <td>768</td>
      <td>0.002465</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000371</td>
      <td>128</td>
      <td>7</td>
      <td>0.008547</td>
      <td>0.001696</td>
      <td>0.173673</td>
      <td>1182720</td>
      <td>3072</td>
      <td>0.010243</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.000520</td>
      <td>512</td>
      <td>7</td>
      <td>0.090611</td>
      <td>0.048209</td>
      <td>0.748644</td>
      <td>18886656</td>
      <td>12288</td>
      <td>0.138820</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.000599</td>
      <td>2048</td>
      <td>7</td>
      <td>1.290427</td>
      <td>1.718569</td>
      <td>2.980135</td>
      <td>302039040</td>
      <td>49152</td>
      <td>3.008996</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.000887</td>
      <td>4608</td>
      <td>7</td>
      <td>6.420555</td>
      <td>15.528301</td>
      <td>12.084268</td>
      <td>1528934400</td>
      <td>110592</td>
      <td>21.948856</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;text.usetex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;n_elements&quot;</span><span class="p">],</span> <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;direct_runtime&quot;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;direct&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;n_elements&quot;</span><span class="p">],</span> <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;iterative_runtime&quot;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;iterative&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Run time (secs)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;n_elements&quot;</span><span class="p">],</span> <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;direct_memory&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;direct&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;n_elements&quot;</span><span class="p">],</span> <span class="n">results_df</span><span class="p">[</span><span class="s2">&quot;iterative_memory&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;iterative&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Memory usage (MB)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/free_matvec_30_0.png" src="../_images/free_matvec_30_0.png" />
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./tdes"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="sa_geometry.html" title="previous page"><span class="section-number">2. </span>A fault and topography mesh of the South America subduction zone.</a>
    <a class='right-next' id="next-link" href="low_rank.html" title="next page"><span class="section-number">4. </span>Low rank approximation of BEM matrices with adaptive cross approximation (ACA).</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By T. Ben Thompson<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-114592151-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </body>
</html>