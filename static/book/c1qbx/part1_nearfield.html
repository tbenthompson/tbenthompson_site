
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Computing boundary integrals with quadrature by expansion (QBX). &#8212; Integral equation tutorials</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/patch.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://tbenthompson.com/book/c1qbx/part1_nearfield.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2. QBX examples for the Laplace equation: fun with screw dislocations" href="part2_screw_dislocation.html" />
    <link rel="prev" title="5. GPU-accelerated hierarchical matrices for triangular dislocation elements." href="../tdes/hmatrix.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-114592151-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Integral equation tutorials</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Integral equation tutorials
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The problem space
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fault_problems.html">
   1. Problems in earthquake science
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The TDE sequence: triangular dislocation elements
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../tdes/sa_tdes.html">
   1. Using TDEs to build a fault model with topography.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tdes/sa_geometry.html">
   2. A fault and topography mesh of the South America subduction zone.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tdes/free_matvec.html">
   3. Minimizing memory usage: a matrix-free iterative solver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tdes/low_rank.html">
   4. Low rank approximation of BEM matrices with adaptive cross approximation (ACA).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tdes/hmatrix.html">
   5. GPU-accelerated hierarchical matrices for triangular dislocation elements.
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The QBX sequence: quadrature by expansion
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. Computing boundary integrals with quadrature by expansion (QBX).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part2_screw_dislocation.html">
   2. QBX examples for the Laplace equation: fun with screw dislocations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part3_surface_intersection.html">
   3. Slip on an infinite strike slip fault in an elastic half space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part4_topography.html">
   4. Topography
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part5_viscoelastic.html">
   5. Viscoelasticity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part6_qd.html">
   6. Quasidynamic earthquake cycles: antiplane
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part7_qd_two_faults.html">
   7. Quasidynamic earthquake cycles on two faults
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="part8_thrust_qd.html">
   8. [DRAFT] Quasidynamic thrust fault earthquake cycles (plane strain)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The volumetric sequence: beyond boundaries
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../volumetric/part1_solve_circle.html">
   1. [DRAFT] Solving a Dirichlet problem on a circle.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../volumetric/part2_mms_circle.html">
   2. [DRAFT] Method of manufactured solutions (MMS) for the Poisson equation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Back matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../references.html">
   References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../thanks.html">
   Thanks!
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/c1qbx/part1_nearfield.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   1.1. Summary
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#near-field-evaluation-for-boundary-integrals">
   1.2. Near-field evaluation for boundary integrals
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-is-qbx">
   1.3. What is QBX?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#qbx-via-complex-power-series">
   1.4. QBX via complex power series
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     1.4.1. Summary
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#implementing-qbx-for-the-double-layer-potential-on-a-circle">
   1.5. Implementing QBX for the double layer potential on a circle
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demonstrating-the-problem">
     1.5.1. Demonstrating the problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#accurate-near-field-evaluation">
     1.5.2. Accurate near-field evaluation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#general-purpose-qbx-implementation">
   1.6. General-purpose QBX implementation
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="computing-boundary-integrals-with-quadrature-by-expansion-qbx">
<h1><span class="section-number">1. </span>Computing boundary integrals with quadrature by expansion (QBX).<a class="headerlink" href="#computing-boundary-integrals-with-quadrature-by-expansion-qbx" title="Permalink to this headline">¶</a></h1>
<div class="section" id="summary">
<h2><span class="section-number">1.1. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>I’ll introduce the basic nearfield evaluation problem that lies at the core of discretizing boundary integral equations.</p></li>
<li><p>Then, I’ll introduce QBX as a solution for this problem and explain a particular form of QBX.</p></li>
<li><p>We’ll implement a very basic single-expansion QBX integrator.</p></li>
<li><p>Then, we’ll use <code class="docutils literal notranslate"><span class="pre">tectosaur2.integrate_term</span></code> in order to generically computing boundary integrals using QBX.</p></li>
<li><p>We’ll look at error rates and show that QBX is accurate almost to machine precision.</p></li>
</ul>
</div>
<div class="section" id="near-field-evaluation-for-boundary-integrals">
<h2><span class="section-number">1.2. </span>Near-field evaluation for boundary integrals<a class="headerlink" href="#near-field-evaluation-for-boundary-integrals" title="Permalink to this headline">¶</a></h2>
<p>Suppose that we’re modeling a fault as a infinitesimally thin surface. And there’s some slip on that surface. And we want to calculate how much displacement that slip has caused near the fault. A common approach is to use <span class="xref myst">triangular or rectangular dislocation elements</span>  but that would limit us to constant slip per element, which leads to stress singularities and unhappiness. So, let’s back off to a fully general mathematical description. This type of surface integral is at the core of a boundary integral method:</p>
<div class="amsmath math notranslate nohighlight" id="equation-34300228-5c9d-459f-ae73-100145a46e93">
<span class="eqno">(1.14)<a class="headerlink" href="#equation-34300228-5c9d-459f-ae73-100145a46e93" title="Permalink to this equation">¶</a></span>\[\begin{equation}
u(\mathbf{p}) = \int_{S} K(\mathbf{p}, \mathbf{q}) \phi(\mathbf{q}) d\mathbf{q}
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(K(\mathbf{p}, \mathbf{q})\)</span> is normally a fundamental solution to a PDE or the derivative thereof.</p>
<p>At a basic level, these integrals are hard because <span class="math notranslate nohighlight">\(K\)</span> is <strong>singular</strong>. Depending on the dimension (2D or 3D) and the particular problem, the singularity will be something like <span class="math notranslate nohighlight">\(\log(r)\)</span> or <span class="math notranslate nohighlight">\(r^{-n}\)</span> where <span class="math notranslate nohighlight">\(r = \|\mathbf{p}-\mathbf{q}\|_2\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> is far away from <span class="math notranslate nohighlight">\(S\)</span>, then the integral is very smooth and well-behaved and can be super easily computed with standard quadrature rules like Gaussian quadrature or the trapezoidal rule. But, if <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> is close to some part of <span class="math notranslate nohighlight">\(S\)</span>, then the singularity in <span class="math notranslate nohighlight">\(K(\mathbf{p},\mathbf{q})\)</span> makes computation of the integral hard. In the boundary integral literature, this is called the <strong>near-field evaluation problem</strong>. Or in the case where <span class="math notranslate nohighlight">\(\mathbf{p} \in S\)</span>, the <strong>singular evaluation problem</strong>.</p>
<p>The brute force solution to the problem is to just compute the integral with a very high order quadrature rule or an adaptive quadrature rule. For the near-field case, using a higher order quadrature order will eventually converge to the correct value but the number of quadrature points will grow prohibitively large as <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> approaches <span class="math notranslate nohighlight">\(S\)</span>. However, for the singular evaluation problem, some integrals will not converge at all. Many approaches have been developed to handle these singular and near-singular integrals (CITE a few?).</p>
</div>
<div class="section" id="what-is-qbx">
<h2><span class="section-number">1.3. </span>What is QBX?<a class="headerlink" href="#what-is-qbx" title="Permalink to this headline">¶</a></h2>
<p>A robust and general solution to nearfield evaluation is a method called quadrature by expansion (<strong>QBX</strong>). The exciting thing about QBX is that we can indirectly compute our boundary integral for observation points (<span class="math notranslate nohighlight">\(p\)</span>) that are very close to or even directly on the boundary while only <em>directly</em> evaluating the integrals for points that are far from the boundary. The basic idea is to form an approximation for <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> “centered” at a point <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> away from <span class="math notranslate nohighlight">\(S\)</span> and then use that proxy to extrapolate to points that are close to <span class="math notranslate nohighlight">\(S\)</span>. There are several versions of QBX depending on the type of proxy used:</p>
<ul class="simple">
<li><p>The <a class="reference external" href="https://arxiv.org/abs/1207.4461">original QBX paper</a><span id="id1">[<a class="reference internal" href="../references.html#id557">Klöckner <em>et al.</em>, 2013</a>]</span> uses a separation of variables technique for the Helmholtz equation to form a series expansion in terms of Hankel functions and Bessel functions. This works for other PDEs if some separation of variables techniques are known. With Poisson and elasticity, we use a complex variable formulation in 2D and spherical harmonic expansions in 3D.</p></li>
<li><p>The <a class="reference external" href="https://arxiv.org/abs/1612.00977">quadrature by kernel-independent expansion (QBKIX) paper</a><span id="id2">[<a class="reference internal" href="../references.html#id858">Rahimian <em>et al.</em>, 2018</a>]</span> forms a proxy set of point sources which replace the original integral locally arounding the expansion point <span class="math notranslate nohighlight">\(c\)</span>. This approach is “kernel-independent” since it will work well for most functions <span class="math notranslate nohighlight">\(K(\mathbf{p}, \mathbf{q})\)</span> even if the functions are complex enough that analytical techniques like separation of variables are too difficult.</p></li>
<li><p>The <a class="reference external" href="https://arxiv.org/pdf/1805.06106.pdf">GIGAQBX algorithm</a><span id="id3">[<a class="reference internal" href="../references.html#id1083">Wala and Klöckner, 2019</a>]</span> derives rigorous error and runtime bounds for QBX combined with the fast multipole method when the same expansion centers are used for both the near and far-field.</p></li>
</ul>
<p>There are several other approaches. All share the share basic ideas but differ in design decisions like whether to apply QBX to only the near-field integrals (“local” QBX) or apply QBX to all the integrals (“global” QBX).</p>
<p>Ultimately, QBX works because even though the surface integral may be singular, <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> is normally a smooth function. Approximating <span class="math notranslate nohighlight">\(u(p)\)</span> directly provides a sort of backdoor around the singularities in <span class="math notranslate nohighlight">\(K(\mathbf{p},\mathbf{q})\)</span>. And, QBX methods are generally efficient because <span class="math notranslate nohighlight">\(c\)</span> is far enough away from <span class="math notranslate nohighlight">\(S\)</span> that the computation of the expansion is fairly cheap.</p>
</div>
<div class="section" id="qbx-via-complex-power-series">
<h2><span class="section-number">1.4. </span>QBX via complex power series<a class="headerlink" href="#qbx-via-complex-power-series" title="Permalink to this headline">¶</a></h2>
<p>Here, I’ll focus specifically on a version of <a class="reference external" href="https://arxiv.org/abs/1610.00823">QBX introduced here in section 5.3</a><span id="id4">[<a class="reference internal" href="../references.html#id32">Askham and Cerfon, 2017</a>]</span> that expands the solution in terms of a complex power series and works well for the Poisson equation and for elasticity in two dimensions.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Even though this particular form of expansion is less popular than others, I think it’s a nice introduction to QBX because the method is somewhat independent of the kernel and can be implemented and explained entirely in terms of the off-surface potential values. For a straight-forward introduction to more standard expansion methods for the 2D Laplace equations, I would recommend section 2.4 of <span id="id5">af Klinteberg and Tornberg [<a class="reference internal" href="../references.html#id6">2018</a>]</span></p>
</div>
<p>First, I’ll define some terminology that we’ll use a lot through all the sections on boundary integral equations:</p>
<ul class="simple">
<li><p>observation point: this is the point <span class="math notranslate nohighlight">\(x\)</span> where we’d like to evaluate <span class="math notranslate nohighlight">\(u(x)\)</span>.</p></li>
<li><p>source surface: this is the surface <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>the expansion center, <span class="math notranslate nohighlight">\(c\)</span> and the expansion radius, <span class="math notranslate nohighlight">\(r\)</span>. The expansion radius is the maximum distance from <span class="math notranslate nohighlight">\(c\)</span> where the expansion is valid.</p></li>
</ul>
<p>To expand, we re-write the observation point into the complex plane. The observation point becomes <span class="math notranslate nohighlight">\(\hat{p} = p_x + ip_y\)</span> and the expansion center becomes <span class="math notranslate nohighlight">\(\hat{c} = c_x + ic_y\)</span>. The expansion center is a distance <span class="math notranslate nohighlight">\(r\)</span> from <span class="math notranslate nohighlight">\(S\)</span>.</p>
<div class="amsmath math notranslate nohighlight" id="equation-37f58a1d-d6bd-423d-b9db-6f31b9beab0a">
<span class="eqno">(1.15)<a class="headerlink" href="#equation-37f58a1d-d6bd-423d-b9db-6f31b9beab0a" title="Permalink to this equation">¶</a></span>\[\begin{equation}
u(x) = Re\big(\sum_{l=0}^{p} \alpha_l(\hat{p} - \hat{c})^l\big)
\end{equation}\]</div>
<p>Then, the expansion coefficients (<span class="math notranslate nohighlight">\(\alpha\)</span>) are computed by computing a clever integral of <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> around a circle with radius <span class="math notranslate nohighlight">\(\delta r\)</span> centered at <span class="math notranslate nohighlight">\(\mathbf{c}\)</span>. For <span class="math notranslate nohighlight">\(l &gt; 0\)</span>, the integral we compute is:</p>
<div class="amsmath math notranslate nohighlight" id="equation-9193592b-0379-474e-b842-373141d48c3d">
<span class="eqno">(1.16)<a class="headerlink" href="#equation-9193592b-0379-474e-b842-373141d48c3d" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\alpha_l = \frac{1}{\pi (\delta r)^l}\int_{0}^{2\pi} u(\mathbf{c} + \delta r(cos \theta, sin \theta)) e^{-il\theta} d\theta
\end{equation}\]</div>
<p>and for <span class="math notranslate nohighlight">\(l=0\)</span>, we simply divide the above integral by two. The values of <span class="math notranslate nohighlight">\(u\)</span> will be computed “directly” by just using a simple quadrature rule on the original surface integral. We’ll normally use Gaussian quadrature, but in the first example below, we’ll actually use the trapezoidal rule because the trapezoidal rule is extremely accurate and efficient for periodic integrands.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="../_images/part1_nearfield_5_0.png" src="../_images/part1_nearfield_5_0.png" />
</div>
</div>
<div class="section" id="id6">
<h3><span class="section-number">1.4.1. </span>Summary<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>So, what’s the full algorithm look like?</p>
<ol class="simple">
<li><p>Choose an expansion center a distance of <span class="math notranslate nohighlight">\(r\)</span> away from the surface.</p></li>
<li><p>Discretize the integrals for the expansion coefficients and identify the points where we will need to evaluate <span class="math notranslate nohighlight">\(u(\mathbf{c} + \delta r(cos \theta, sin \theta))\)</span>.</p></li>
<li><p>Evaluate <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> for those points by directly evaluating <span class="math notranslate nohighlight">\(\int K(\mathbf{p}, \mathbf{q}) \phi(\mathbf{q}) d\mathbf{q}\)</span> using a simple quadrature rule (e.g. Gaussian quadrature). Because we choose, <span class="math notranslate nohighlight">\(\delta = 1/2\)</span>, the closest we will have to evaluate <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> is <span class="math notranslate nohighlight">\(r/2\)</span>.</p></li>
<li><p>Integrate (sum) to compute <span class="math notranslate nohighlight">\(\alpha_l\)</span>.</p></li>
<li><p>Now that we have the coefficients <span class="math notranslate nohighlight">\(\alpha_l\)</span>, to evaluate <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> at any point arbitrarily close to the surface, simply evaluate the complex power series and take the real part.</p></li>
</ol>
<p>Some comments about QBX:</p>
<ul class="simple">
<li><p>Because the evaluation of the series is independent of the computation of the coefficients, we can compute <strong>many near-field values for the price of one</strong>.</p></li>
<li><p>The method actually works just as well for computing a <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> directly on the boundary. To be precise, we can compute a limit to the boundary like <span class="math notranslate nohighlight">\(\lim_{\mathbf{p} \to S^+}u(\mathbf{p})\)</span>. Thus, QBX can actually <strong>replace the singular quadrature required in many boundary integral methods</strong>.</p></li>
<li><p>The method works best when there are no singularities in <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span>. The most common violation of this is a sharp corner in <span class="math notranslate nohighlight">\(S\)</span>. When there are singularities in <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span>, QBX will still work, but the expansion center <span class="math notranslate nohighlight">\(c\)</span> will need to be closer to the surface and, as a result, a high number of quadrature points will be needed in the vicinity of the corner.</p></li>
<li><p>There are four parameters which all control the accuracy. The location of the expansion center, <span class="math notranslate nohighlight">\(c\)</span>. The distance to offset from the surface, <span class="math notranslate nohighlight">\(r\)</span>. The order of the expansion, <span class="math notranslate nohighlight">\(p\)</span>. And the order of quadrature method used to compute the coefficients of the expansion, <span class="math notranslate nohighlight">\(n_q\)</span>. They interact in somewhat complex ways.</p></li>
<li><p>Increasing <span class="math notranslate nohighlight">\(p\)</span> will improve the accuracy of the expansion up to a point, but eventually the higher order terms in the expansion will become corrupted by the error introduced by the numerical integration. So, in order to increase <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(n_q\)</span> must also increase.</p></li>
<li><p>By increasing <span class="math notranslate nohighlight">\(r\)</span>, the expansion is formed further from the surface and (holding <span class="math notranslate nohighlight">\(n_q\)</span> constant) the expansion coefficients will be computed more accurately, but (holding <span class="math notranslate nohighlight">\(p\)</span> constant) the accuracy of the expansion near the surface will decrease because the distance from the evaluation point to the expansion center is larger.</p></li>
<li><p>The choices of <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(c\)</span> are closely connected. Since the only value we ultimately care about is <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span>, we can choose the exact location and size of the “expansion circle” defined by the expansion center <span class="math notranslate nohighlight">\(c\)</span>, the expansion radius <span class="math notranslate nohighlight">\(r\)</span> and the radius of integration <span class="math notranslate nohighlight">\(\delta r\)</span>. Let’s list the considerations that go into this judgement:</p>
<ol class="simple">
<li><p>Larger radius is better: Holding the expansion center fixed, a larger expansion radius is beneficial because the expansion can cover more ground so more interior points can be computed by a single expansion.</p></li>
<li><p>Larger radius is better: Holding the expansion center fixed, a larger expansion radius means the values <span class="math notranslate nohighlight">\(u(\mathbf{c} + \delta r(cos \theta, sin \theta))\)</span> can be computed more cheaply because the evaluation points are further from the source surface.</p></li>
<li><p>Hard upper limit on expansion radius: Holding the expansion center fixed, too large a radius will cause the expansion circle to intersect the source surface. Expanding requires the underlying <span class="math notranslate nohighlight">\(u\)</span> field to be smooth and allowing the expansion circle to intersect the source surface violates that constraint because <span class="math notranslate nohighlight">\(u\)</span> is not smooth across <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Closer expansion centers are more accurate: Holding the number of terms in the power series constant, if we increase the distance from the expansion center <span class="math notranslate nohighlight">\(c\)</span> to the observation point <span class="math notranslate nohighlight">\(x\)</span>, we will also increase the error in computing <span class="math notranslate nohighlight">\(u(x)\)</span>.</p></li>
<li><p>Closer expansion centers are more expensive: Remember that we compute the values <span class="math notranslate nohighlight">\(u(\mathbf{c} + \delta r(cos \theta, sin \theta))\)</span> directly by performing a direct Gaussian quadrature of the integral. The integrand will be more peaked when the evaluation points are closer to the source surface. More peaked integrands will require a higher quadrature order to be accurate.</p></li>
<li><p>The conclusion is that, we should <strong>choose the largest radius that doesn’t intersect the source surface</strong>. For the expansion center, there is a balance between computational cost and accuracy. And <span class="math notranslate nohighlight">\(\delta = 0.5\)</span> empirically works well.</p></li>
</ol>
</li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>How easily do these double layer potential calculations extend to 2D plane-strain elasticity? Super easily. In fact, basically nothing needs to change except that we do everything four times, once for each component of the 2x2 tensor form of the equations! Extension to 3D elasticity is even more involved from a software and computational standpoint, but also does not require major algorithmic changes. On the other hand, oscillatory Green’s functions of the Helmholtz equation might require some re-engineering.</p>
</div>
</div>
</div>
<div class="section" id="implementing-qbx-for-the-double-layer-potential-on-a-circle">
<h2><span class="section-number">1.5. </span>Implementing QBX for the double layer potential on a circle<a class="headerlink" href="#implementing-qbx-for-the-double-layer-potential-on-a-circle" title="Permalink to this headline">¶</a></h2>
<p>Great, let’s put together a simple implementation for the Laplace double layer potential! The double layer potential is one of the fundamental objects of potential theory and, physically, is the integral that computes the electric or magnetic potential due to a dipolar surface. Or, the integral that computes the displacement due to an earthquake under the assumption of antiplane strain.</p>
<p>First, we’ll set up a few useful functions. We’ll create a source surface/mesh out of circle evaluated the nodes of a trapezoidal quadrature rule.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">SourceSurface</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple description of a source surface consists of:</span>

<span class="sd">    `quad_pts` and `quad_wts`: a set of quadrature nodes and weights specifying</span>
<span class="sd">        where in [-1, 1] parameter space each interpolation point lies.</span>

<span class="sd">    `pts`: a set of interpolation points that define the mesh,</span>

<span class="sd">    `normals`: the normal vectors to the surface at the points,</span>

<span class="sd">    `jacobians`: the determinant of the curve&#39;s jacobian at the points</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quad_pts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">quad_wts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">pts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">normals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">jacobians</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_pts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trapezoidal_rule</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The n-point trapezoidal rule on [-1, 1].</span>
<span class="sd">    Returns tuple of (points, weights)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a circular surface with the normal vectors pointing outwards.</span>

<span class="sd">    The natural choice for quadrature on a circle is a trapezoidal rule due</span>
<span class="sd">    to its exponential convergence on a periodic domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">quad_pts</span><span class="p">,</span> <span class="n">quad_wts</span> <span class="o">=</span> <span class="n">trapezoidal_rule</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Convert from [-1,1] to [0,2*pi]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">quad_pts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]])</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">pts</span>
    <span class="n">jacobians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SourceSurface</span><span class="p">(</span><span class="n">quad_pts</span><span class="p">,</span> <span class="n">quad_wts</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">jacobians</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The double layer potential takes the form of a standard boundary integral operator, where the specific form of <span class="math notranslate nohighlight">\(K(\mathbf{p}, \mathbf{q})\)</span> can be found in the <code class="docutils literal notranslate"><span class="pre">double_layer_matrix</span></code> code below.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>What is the distinction between the “double layer <strong>potential</strong>” and the “double layer <strong>kernel</strong>”? The potential is the full integral <span class="math notranslate nohighlight">\(\int_S K(\mathbf{p}, \mathbf{q}) \phi dS\)</span> whereas the kernel is just the function <span class="math notranslate nohighlight">\(K(\mathbf{p}, \mathbf{q})\)</span>. Authors vary in how precise they distinguish these two things.</p>
</div>
<div class="amsmath math notranslate nohighlight" id="equation-4a0432ea-2896-4357-8f6c-f6ce087637f6">
<span class="eqno">(1.17)<a class="headerlink" href="#equation-4a0432ea-2896-4357-8f6c-f6ce087637f6" title="Permalink to this equation">¶</a></span>\[\begin{equation}
u(\mathbf{p}) = \int_{S} K(\mathbf{p}, \mathbf{q}) \phi(\mathbf{q}) d\mathbf{q}
\end{equation}\]</div>
<p>Discretizing the integral for many observation points indexed by <span class="math notranslate nohighlight">\(i\)</span> and for many quadrature source points indexed by <span class="math notranslate nohighlight">\(j\)</span>, the result is</p>
<div class="amsmath math notranslate nohighlight" id="equation-f9b6a4f5-2021-4ea3-80c5-050ee3807fe5">
<span class="eqno">(1.18)<a class="headerlink" href="#equation-f9b6a4f5-2021-4ea3-80c5-050ee3807fe5" title="Permalink to this equation">¶</a></span>\[\begin{equation}
u_i = \sum_j w_j K(\mathbf{p}_i, \mathbf{q}_j) \phi(\mathbf{q}_j)
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_j\)</span> are the quadrature weights. This can be written in matrix form:</p>
<div class="amsmath math notranslate nohighlight" id="equation-8589dab6-8ce0-4ed8-a7e2-0cdf7cf8d6d1">
<span class="eqno">(1.19)<a class="headerlink" href="#equation-8589dab6-8ce0-4ed8-a7e2-0cdf7cf8d6d1" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\textbf{u} = \textbf{A} \textbf{b}
\end{equation}\]</div>
<p>The matrix of interest is <span class="math notranslate nohighlight">\(A_{ij} = w_j * K(\mathbf{p}_i, \mathbf{q}_j)\)</span>. The function below computes that matrix for <span class="math notranslate nohighlight">\(K(\mathbf{p}, \mathbf{q})\)</span>.</p>
<div class="cell tag_remove-input docutils container">
</div>
<div class="section" id="demonstrating-the-problem">
<h3><span class="section-number">1.5.1. </span>Demonstrating the problem<a class="headerlink" href="#demonstrating-the-problem" title="Permalink to this headline">¶</a></h3>
<p>So, let’s plot up what <span class="math notranslate nohighlight">\(u(\mathbf{p})\)</span> looks like. For the rest of this section, we’ll use the simple <span class="math notranslate nohighlight">\(\phi(\mathbf{q}) = q_y\)</span> (the y component of the source location) as the source function and use a circle as the surface <span class="math notranslate nohighlight">\(S\)</span>. In the next section, we’ll explore some more interesting geometries and functions. Let’s start by using a fairly low quadrature order, just 200 points on the whole circle. And I’ll plot the resulting field on a 100x100 grid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pts_grid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes two 1D arrays specifying X and Y values and returns a</span>
<span class="sd">    (xs.size * ys.size, 2) array specifying the grid of points in the Cartesian</span>
<span class="sd">    product of `xs` and `ys`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nobs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="n">nobs</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="n">nobs</span><span class="p">)</span>
<span class="n">obs_pts</span> <span class="o">=</span> <span class="n">pts_grid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
<span class="n">surface_low</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And this is the meat of the <span class="math notranslate nohighlight">\(\textbf{u} = \textbf{A}\textbf{b}\)</span> calculation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">double_layer_matrix</span><span class="p">(</span><span class="n">surface_low</span><span class="p">,</span> <span class="n">obs_pts</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># phi = y_2</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>  <span class="c1"># u = Ab</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span> <span class="c1"># reshape to a grid for plotting</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">,</span>
    <span class="n">ys</span><span class="p">,</span>
    <span class="n">u</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;$u$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/part1_nearfield_19_0.png" src="../_images/part1_nearfield_19_0.png" />
</div>
</div>
<p>Pretty picture! But, you can immediately see the uglyness near the boundary! This is what we’ll solve with QBX. Let’s actually quantify that error. We’ll compare our 200 point integration against a 2000 point integration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zoomnobs</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">zoomx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">]</span>
<span class="n">zoomy</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">]</span>
<span class="n">zoomxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">zoomx</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">)</span>
<span class="n">zoomys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">zoomy</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">)</span>
<span class="n">zoomobs_pts</span> <span class="o">=</span> <span class="n">pts_grid</span><span class="p">(</span><span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">)</span>

<span class="n">zoomu_low</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">double_layer_matrix</span><span class="p">(</span><span class="n">surface_low</span><span class="p">,</span> <span class="n">zoomobs_pts</span><span class="p">)</span>
    <span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">zoomnobs</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">))</span>
<span class="p">)</span>

<span class="n">surface_high</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>
<span class="n">zoomu_high</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">double_layer_matrix</span><span class="p">(</span><span class="n">surface_high</span><span class="p">,</span> <span class="n">zoomobs_pts</span><span class="p">)</span>
    <span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">surface_high</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">zoomnobs</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;50 pt solution&#39;</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">zoomu_low</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">zoomu_low</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;2000 pt solution&#39;</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">zoomu_high</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">zoomu_high</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;$u$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Log error&#39;</span><span class="p">)</span>
<span class="n">logerror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zoomu_low</span> <span class="o">-</span> <span class="n">zoomu_high</span><span class="p">))</span>
<span class="n">logerror</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logerror</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">12.0</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">logerror</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">logerror</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;$\log_</span><span class="si">{10}</span><span class="s2">(\|u_h - u_l\|)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/var/folders/mt/cmys2v_143q1kpcrdt5wcdyr0000gn/T/ipykernel_84115/4222150689.py:48: RuntimeWarning: divide by zero encountered in log10
  logerror = np.log10(np.abs(zoomu_low - zoomu_high))
</pre></div>
</div>
<img alt="../_images/part1_nearfield_22_1.png" src="../_images/part1_nearfield_22_1.png" />
</div>
</div>
<p>We’re zoomed in on the upper right edge of the circle here. You can see the little dipoles from the low order quadrature on the left. In the middle, the super high order quadrature cleans up the picture. The right hand figure shows the <span class="math notranslate nohighlight">\(\log_{10}\)</span> error in the low order integrals. The error very close to the surface is more-or-less 100%. There are two important take-aways here:</p>
<ol class="simple">
<li><p>The number of quadrature points required for accurate direct quadrature scales inversely with the distance of the observation point to the source surface. In the figure above, if you zoomed in by a factor of 10x, you’d see the dipoles again even with the 2000 point quadrature. This isn’t actually too bad. Most of the time we don’t need to compute integrals super close to the source surface and if we do, adaptive quadrature has been efficient enough for most applications I’ve worked on.</p></li>
<li><p>The real problem is that we <strong>often need to compute integrals where the observation point lies directly on the source surface</strong>. If the number of quadrature points required for an accurate integral is scaling inversely with the distance from the source surface, a naive extrapolation implies that an <em>infinite number of quadrature points</em> will be required to accurately evaluate the integral for an observation point on the source surface. This is where QBX is going to save the day.</p></li>
</ol>
</div>
<div class="section" id="accurate-near-field-evaluation">
<h3><span class="section-number">1.5.2. </span>Accurate near-field evaluation<a class="headerlink" href="#accurate-near-field-evaluation" title="Permalink to this headline">¶</a></h3>
<p>Let’s try again with the low-order quadrature rule but this time using QBX! We’re going to use a tenth order expansion offset from the source surface by about 0.2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qbx_p</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">qbx_r</span> <span class="o">=</span> <span class="mf">0.20</span>
<span class="n">qbx_center_x</span> <span class="o">=</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qbx_r</span><span class="p">)</span>
<span class="n">qbx_center_y</span> <span class="o">=</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qbx_r</span><span class="p">)</span>
<span class="n">qbx_center_x</span><span class="p">,</span> <span class="n">qbx_center_y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1.0857924629592233, 0.5109351498780872)
</pre></div>
</div>
</div>
</div>
<p>So, we now need to compute the circular integrals for the coefficients. A rule of thumb is to use a trapezoidal rule with <span class="math notranslate nohighlight">\(2p\)</span> points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trap_x</span><span class="p">,</span> <span class="n">trap_weights</span> <span class="o">=</span> <span class="n">trapezoidal_rule</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qbx_p</span><span class="p">)</span>

<span class="c1"># transform the quadrature rule from [-1, 1] to [0, 2*pi]</span>
<span class="n">trap_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">trap_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># multiply the quadrature weights by the jacobian of the transformation</span>
<span class="n">trap_weights</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
</pre></div>
</div>
</div>
</div>
<p>Our expansion center is approximately a distance of 0.5 from the boundary, so our coefficient integrals are computed a distance of 0.25 from the expansion center (remember <span class="math notranslate nohighlight">\(\delta = 1/2\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qbx_delta_r</span> <span class="o">=</span> <span class="n">qbx_r</span> <span class="o">*</span> <span class="mf">0.5</span>
<span class="c1"># (qbx_x, qbx_y) defines the points used for computing the circular coefficient integrals centered at the expansion center.</span>
<span class="n">qbx_x</span> <span class="o">=</span> <span class="n">qbx_delta_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">trap_theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">qbx_center_x</span>
<span class="n">qbx_y</span> <span class="o">=</span> <span class="n">qbx_delta_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">trap_theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">qbx_center_y</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we need the value of <span class="math notranslate nohighlight">\(u(x)\)</span> at the points <code class="docutils literal notranslate"><span class="pre">(qbx_x,</span> <span class="pre">qbx_y)</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qbx_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">qbx_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">qbx_y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]))</span>
<span class="n">qbx_u</span> <span class="o">=</span> <span class="n">double_layer_matrix</span><span class="p">(</span><span class="n">surface_low</span><span class="p">,</span> <span class="n">qbx_xy</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And here we implement the coefficient integrals. This looks ugly, but it’s a direct implementation of the discretized coefficient integrals where <span class="math notranslate nohighlight">\(\omega_i\)</span> are the quadrature weights <code class="docutils literal notranslate"><span class="pre">trap_ws</span></code></p>
<div class="math notranslate nohighlight">
\[\alpha_l = \frac{1}{\pi (\delta r)^l}\sum_{i=0}^{2p} \omega_i u(\mathbf{c} + \delta r(cos \theta_i, sin \theta_i)) e^{-il\theta_i} \]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qbx_p</span><span class="p">):</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">qbx_delta_r</span> <span class="o">**</span> <span class="n">L</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trap_weights</span> <span class="o">*</span> <span class="n">qbx_u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">trap_theta</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>We convert the expansion center and the observation points to be complex.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zoom_complex</span> <span class="o">=</span> <span class="p">(</span><span class="n">zoomobs_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">zoomobs_pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">zoomnobs</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">))</span>
<span class="n">qbx_center</span> <span class="o">=</span> <span class="n">qbx_center_x</span> <span class="o">+</span> <span class="n">qbx_center_y</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>
</pre></div>
</div>
</div>
</div>
<p>And finally, evaluate the expansion in complex space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zoomu_qbx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">zoomu_low</span><span class="p">)</span>
<span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qbx_p</span><span class="p">):</span>
    <span class="n">zoomu_qbx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">zoom_complex</span> <span class="o">-</span> <span class="n">qbx_center</span><span class="p">)</span> <span class="o">**</span> <span class="n">L</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;QBX solution&#39;</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">zoomu_qbx</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">zoomu_qbx</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;2000 pt solution&#39;</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">zoomu_high</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">zoomu_high</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;$u$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Log error&#39;</span><span class="p">)</span>
<span class="n">logerror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zoomu_qbx</span> <span class="o">-</span> <span class="n">zoomu_high</span><span class="p">))</span>
<span class="n">logerror</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logerror</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">12.0</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">logerror</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">logerror</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;$\log_</span><span class="si">{10}</span><span class="s2">(\|u_h - u_l\|)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/part1_nearfield_37_0.png" src="../_images/part1_nearfield_37_0.png" />
</div>
</div>
<p>The left panel here shows <span class="math notranslate nohighlight">\(u(x)\)</span> from the QBX evaluation, the middle panel shows <span class="math notranslate nohighlight">\(u(x)\)</span> from the 2000 point quadrature and the right panel shows the <span class="math notranslate nohighlight">\(\log_{10}\)</span> error in the QBX evaluation. Take-aways:</p>
<ul class="simple">
<li><p>The error near the portion of the surface closest to the expansion center is now quite good. We’re succesfully doing an accurate near-field evaluation despite using a small number of source quadrature points!</p></li>
<li><p>Points far away from the expansion center are less accurate.</p></li>
<li><p>The QBX expansion is entirely wrong interior to the circle on the other side of the surface. This is entirely expected since there is a jump in <span class="math notranslate nohighlight">\(u(x)\)</span> across the surface and a step function like that would be impossible to approximate with a power series.</p></li>
</ul>
</div>
</div>
<div class="section" id="general-purpose-qbx-implementation">
<h2><span class="section-number">1.6. </span>General-purpose QBX implementation<a class="headerlink" href="#general-purpose-qbx-implementation" title="Permalink to this headline">¶</a></h2>
<p>While what we did so far is a cool demonstration, it’s not a practical implementation. Ultimately, we need to be able to provide a big list of observation points and expect the code to choose whether to compute the integral directly or, if a point is near the surface, use QBX. And, we need to assign observation points to which expansion they are going to use. To do this, we will use the <code class="docutils literal notranslate"><span class="pre">tectosaur2.integrate_term</span></code> function which:</p>
<ol class="simple">
<li><p>Constructs a far-field matrix for the observation points and source points which are not very close to each other. These matrix entries are computed directly without QBX.</p></li>
<li><p>Identifies those observation points that needed to handled more carefully because they are near some portion of the source surface. These are split into nearfield observation points that will be handled with a simple adaptive quadrature function and QBX observation points that will use expansions for evaluation.</p></li>
<li><p>Identifies the optimal expansion center for each QBX observation point and computes QBX matrix entries. The expansion order is adaptively chosen to satisfy the tolerance specified by the <code class="docutils literal notranslate"><span class="pre">tol</span></code> parameter. Adaptive quadrature is used to accurately compute the expansion coefficients.</p></li>
<li><p>Performs adaptive quadrature for the nearfield observation points.</p></li>
<li><p>Combines the farfield, nearfield and QBX matrix components together to construct the matrix representing the discrete integral operator.</p></li>
</ol>
<p>The main three parameters for the <code class="docutils literal notranslate"><span class="pre">integrate_term</span></code> function are:</p>
<ol class="simple">
<li><p>The integral kernel. In this case, the double layer kernel.</p></li>
<li><p>The observation points.</p></li>
<li><p>The source surface.</p></li>
</ol>
<p>Below, we’ll use this function to calculate an extremely accurate solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tectosaur2</span> <span class="kn">import</span> <span class="n">integrate_term</span><span class="p">,</span> <span class="n">unit_circle</span><span class="p">,</span> <span class="n">gauss_rule</span>
<span class="kn">from</span> <span class="nn">tectosaur2.laplace2d</span> <span class="kn">import</span> <span class="n">double_layer</span>
<span class="n">circle_tct</span> <span class="o">=</span> <span class="n">unit_circle</span><span class="p">(</span><span class="n">gauss_rule</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">max_curvature</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">bie_mat</span> <span class="o">=</span> <span class="n">integrate_term</span><span class="p">(</span><span class="n">double_layer</span><span class="p">,</span> <span class="n">zoomobs_pts</span><span class="p">,</span> <span class="n">circle_tct</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="n">zoomu_full_qbx</span> <span class="o">=</span> <span class="n">bie_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">circle_tct</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">zoomnobs</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Integration failed for observation point (0.970551, 0.241479) , source panel center at: (0.974664, 0.223673), panel_idx: 8, n_integrals: 100
Expansion center: (0.970461, 0.241458) with expansion radius: 9.23206e-05
The maximum estimated coefficient error: 1.48629e-09 with tolerance: 1e-12
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/tbent/Dropbox/active/eq/tectosaur2/tectosaur2/integrate.py:201: UserWarning: Some integrals failed to converge during adaptive integration. This an indication of a problem in either the integration or the problem formulation.
  warnings.warn(
</pre></div>
</div>
</div>
</div>
<p>We’ll also create a second solution where we use just a single QBX center with index 14. We’ll use the make-shift we calculated in the previous section to do this. Having this single expansion solution is just a nice comparison. Doing this will also demonstrate one of the complexities in a full solution: deciding when to use QBX and when to use a direct evaluation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For most of the observation points, we&#39;ll use the direct quadrature.</span>
<span class="n">zoomu_qbx14</span> <span class="o">=</span> <span class="n">zoomu_low</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># When should we use QBX? When an observation point is close to the expansion</span>
<span class="c1"># center and also close to the source surface.</span>
<span class="n">dist_to_exp_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
    <span class="p">(</span><span class="n">zoomobs_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">qbx_center_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">zoomobs_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">qbx_center_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">)</span>
<span class="n">dist_to_src_surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">zoomobs_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zoomobs_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">use_qbx</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_to_exp_center</span> <span class="o">&lt;</span> <span class="n">qbx_r</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist_to_src_surface</span> <span class="o">&lt;</span> <span class="n">qbx_r</span><span class="p">)</span>

<span class="c1"># Compute the QBX solution when use_qbx is True</span>
<span class="n">use_qbx_complex</span> <span class="o">=</span> <span class="n">zoomobs_pts</span><span class="p">[</span><span class="n">use_qbx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">zoomobs_pts</span><span class="p">[</span><span class="n">use_qbx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>
<span class="n">zoomu_qbx14</span><span class="p">[</span><span class="n">use_qbx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qbx_p</span><span class="p">):</span>
    <span class="n">zoomu_qbx14</span><span class="p">[</span><span class="n">use_qbx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">use_qbx_complex</span> <span class="o">-</span> <span class="n">qbx_center</span><span class="p">)</span> <span class="o">**</span> <span class="n">L</span><span class="p">))</span>
<span class="n">zoomu_qbx14</span> <span class="o">=</span> <span class="n">zoomu_qbx14</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">zoomnobs</span><span class="p">,</span> <span class="n">zoomnobs</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;axes.facecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.facecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;savefig.facecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;savefig.transparent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">logerror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zoomu_high</span> <span class="o">-</span> <span class="n">zoomu_low</span><span class="p">))</span>
<span class="n">logerror</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logerror</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">17.0</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">error_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">logerror</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">logerror</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">logerror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zoomu_high</span> <span class="o">-</span> <span class="n">zoomu_qbx14</span><span class="p">))</span>
<span class="n">logerror</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logerror</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">17.0</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">logerror</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">logerror</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">logerror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zoomu_high</span> <span class="o">-</span> <span class="n">zoomu_full_qbx</span><span class="p">))</span>
<span class="n">logerror</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logerror</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">17.0</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">surface_low</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cntf</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">zoomxs</span><span class="p">,</span> <span class="n">zoomys</span><span class="p">,</span> <span class="n">logerror</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
    <span class="n">zoomxs</span><span class="p">,</span>
    <span class="n">zoomys</span><span class="p">,</span>
    <span class="n">logerror</span><span class="p">,</span>
    <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">levels</span><span class="o">=</span><span class="n">error_levels</span><span class="p">,</span>
    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">zoomx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">zoomy</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

<span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.97</span><span class="p">)</span>
<span class="n">cbar_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.905</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">,</span> <span class="mf">0.015</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="n">cbar_ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cntf</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cbar_ax</span><span class="p">)</span>

<span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span>
    <span class="s2">&quot;$\log_</span><span class="si">{10}</span><span class="s2">(\|\hat</span><span class="si">{u}</span><span class="s2"> - \hat</span><span class="si">{u}</span><span class="s2">_{</span><span class="se">\\</span><span class="s2">textrm</span><span class="si">{QBX}</span><span class="s2">}\|)$&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span>
<span class="p">)</span>
<span class="n">cb</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">cbytick_obj</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">getp</span><span class="p">(</span><span class="n">cb</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="s2">&quot;yticklabels&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">cbytick_obj</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/part1_nearfield_42_0.png" src="../_images/part1_nearfield_42_0.png" />
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Below, we tested QBX against an adaptive quadrature computation. They match to 13 digits. Why don’t we use this adaptive quadrature approach all the time? The answer is that it’s very slow and it won’t work at all if the observation point is precisely on the source surface.</p>
</div>
<p>The left figure shows the <span class="math notranslate nohighlight">\(\log_{10}\)</span> error for a naive brute-force integration. The middle figure shows the <span class="math notranslate nohighlight">\(\log_{10}\)</span> error when we use a single QBX expansion center. The right figure shows the <span class="math notranslate nohighlight">\(\log_{10}\)</span> when we use the closest QBX expansion center for every exterior point close to the boundary.
We can see some remaining error right near the source surface. This remaining error is actually entirely from the 2000 direct quadrature side. To prove that, I’ll compare the QBX solution for the point with the worst error against an adaptively integrated solution. I think this is a nice way to finish up because it demonstrates how QBX is efficiently computing an integral to machine precision in a situation where even a 2000 point quadrature rule is suffering over 100% error.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the index of the point with the highest log error.</span>
<span class="n">worst_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logerror</span><span class="p">)</span>
<span class="n">ox</span><span class="p">,</span> <span class="n">oy</span> <span class="o">=</span> <span class="n">zoomobs_pts</span><span class="p">[</span><span class="n">worst_idx</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ox</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">oy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="p">((</span><span class="n">ox</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="n">sx</span> <span class="o">+</span> <span class="p">(</span><span class="n">oy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">sy</span>
    <span class="k">return</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">kernel</span>

<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="n">adaptive_soln</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The QBX solution is&#39;</span><span class="p">,</span> <span class="n">zoomu_full_qbx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">worst_idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The 2000 point solution is&#39;</span><span class="p">,</span> <span class="n">zoomu_high</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">worst_idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The QBX error is&#39;</span><span class="p">,</span> <span class="n">adaptive_soln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">zoomu_full_qbx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">worst_idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The 2000 point quadrature error is&#39;</span><span class="p">,</span> <span class="n">adaptive_soln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">zoomu_high</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">worst_idx</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The QBX solution is 0.26919570868980797
The 2000 point solution is 2.3843894039954843
The QBX error is 5.69266855876549e-13
The 2000 point quadrature error is -2.115193695305107
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./c1qbx"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../tdes/hmatrix.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">5. </span>GPU-accelerated hierarchical matrices for triangular dislocation elements.</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="part2_screw_dislocation.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2. </span>QBX examples for the Laplace equation: fun with screw dislocations</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By T. Ben Thompson<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>